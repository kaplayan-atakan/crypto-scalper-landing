import { useState, useEffect, useCallback } from 'react'
import { fetchMarketChartRange, symbolToCoinGeckoIdAsync } from '../lib/coingecko'
import { CacheManager } from '../utils/cacheManager'
import { rateLimiter } from '../utils/rateLimiter'
import { CacheTTL, ChartTimeframe, TIMEFRAME_WINDOW_MINUTES } from '../types/coingecko'
import type { MarketChartPoint, OHLCPoint, CoinGeckoConfig, CoinCacheData } from '../types/coingecko'

/**
 * Interpolate candles to create finer granularity
 * E.g., split 1 x 30min candle into 6 x 5min candles
 */
function interpolateCandles(candles: OHLCPoint[], targetIntervalSeconds: number): OHLCPoint[] {
  if (candles.length < 2) return candles
  
  const result: OHLCPoint[] = []
  
  for (let i = 0; i < candles.length; i++) {
    const candle = candles[i]
    const nextCandle = candles[i + 1]
    
    // Calculate how many sub-candles we need
    const candleDuration = nextCandle 
      ? nextCandle.timestamp - candle.timestamp
      : targetIntervalSeconds // Assume last candle has target duration
    
    const subCandleCount = Math.max(1, Math.floor(candleDuration / targetIntervalSeconds))
    
    if (subCandleCount === 1) {
      // No interpolation needed
      result.push(candle)
      continue
    }
    
    // Linear interpolation for price movement
    const priceRange = candle.high - candle.low
    const priceStep = (candle.close - candle.open) / subCandleCount
    
    for (let j = 0; j < subCandleCount; j++) {
      const subTimestamp = candle.timestamp + (j * targetIntervalSeconds)
      
      // Create interpolated sub-candle
      const subOpen = j === 0 ? candle.open : candle.open + (priceStep * j)
      const subClose = candle.open + (priceStep * (j + 1))
      
      // Add some realistic variance for high/low
      const variance = priceRange * 0.1 * Math.random()
      const subHigh = Math.max(subOpen, subClose) + variance
      const subLow = Math.min(subOpen, subClose) - variance
      
      result.push({
        timestamp: subTimestamp,
        open: subOpen,
        high: Math.min(subHigh, candle.high), // Don't exceed original high
        low: Math.max(subLow, candle.low),     // Don't go below original low
        close: subClose
      })
    }
  }
  
  console.log(`ðŸ”€ Interpolated ${candles.length} candles â†’ ${result.length} sub-candles`)
  return result
}

/**
 * Aggregate candles to create coarser granularity
 * E.g., combine 3 x 5min candles into 1 x 15min candle
 */
function aggregateCandles(candles: OHLCPoint[], targetIntervalSeconds: number): OHLCPoint[] {
  if (candles.length === 0) return []
  
  // Group candles by target interval
  const buckets = new Map<number, OHLCPoint[]>()
  
  candles.forEach(candle => {
    const bucketTime = Math.floor(candle.timestamp / targetIntervalSeconds) * targetIntervalSeconds
    if (!buckets.has(bucketTime)) {
      buckets.set(bucketTime, [])
    }
    buckets.get(bucketTime)!.push(candle)
  })
  
  // Aggregate each bucket
  const result = Array.from(buckets.entries())
    .map(([timestamp, group]) => ({
      timestamp,
      open: group[0].open,
      high: Math.max(...group.map(c => c.high)),
      low: Math.min(...group.map(c => c.low)),
      close: group[group.length - 1].close
    }))
    .sort((a, b) => a.timestamp - b.timestamp)
  
  console.log(`ðŸ“Š Aggregated ${candles.length} candles â†’ ${result.length} x ${targetIntervalSeconds/60}m candles`)
  return result
}

/**
 * Resample candles to match target timeframe
 * Handles both upsampling (interpolation) and downsampling (aggregation)
 */
function resampleToTimeframe(candles: OHLCPoint[], targetTimeframe: ChartTimeframe): OHLCPoint[] {
  if (candles.length === 0) return []
  
  // Calculate average interval of source candles
  let avgInterval = 0
  if (candles.length > 1) {
    for (let i = 1; i < candles.length; i++) {
      avgInterval += (candles[i].timestamp - candles[i-1].timestamp)
    }
    avgInterval = Math.floor(avgInterval / (candles.length - 1))
  } else {
    avgInterval = 300 // Default 5 minutes
  }
  
  // Target interval in seconds
  const targetInterval = {
    [ChartTimeframe.ONE_MIN]: 60,
    [ChartTimeframe.THREE_MIN]: 180,
    [ChartTimeframe.FIVE_MIN]: 300,
    [ChartTimeframe.FIFTEEN_MIN]: 900,
  }[targetTimeframe]
  
  console.log(`â±ï¸ Source interval: ${avgInterval}s (${avgInterval/60}m), Target: ${targetInterval}s (${targetInterval/60}m)`)
  
  if (avgInterval === targetInterval) {
    // No resampling needed
    console.log(`âœ… No resampling needed - intervals match`)
    return candles
  } else if (avgInterval > targetInterval) {
    // Need to interpolate (split candles)
    console.log(`ï¿½ Upsampling: splitting ${avgInterval}s â†’ ${targetInterval}s candles`)
    return interpolateCandles(candles, targetInterval)
  } else {
    // Need to aggregate (combine candles)
    console.log(`ðŸ”¼ Downsampling: aggregating ${avgInterval}s â†’ ${targetInterval}s candles`)
    return aggregateCandles(candles, targetInterval)
  }
}

/**
 * Aggregate 5-minute OHLC candles into 15-minute candles
 * Groups every 3 consecutive 5m candles into one 15m candle
 */
/**
 * Calculate optimal time window centered around trade execution
 * Ensures trade timestamp is visible in the chart
 * Adds Â±5min tolerance to guarantee at least 1 candle
 */
function calculateTradeWindow(tradeTime: number, timeframe: ChartTimeframe) {
  const windowMinutes = TIMEFRAME_WINDOW_MINUTES[timeframe]
  const halfWindow = (windowMinutes * 60) / 2 // seconds
  
  const now = Math.floor(Date.now() / 1000)
  
  // Center trade time in the window
  let fromTs = Math.floor(tradeTime - halfWindow)
  let toTs = Math.floor(tradeTime + halfWindow)
  
  // If trade is very recent, extend to current time
  if (toTs > now) {
    toTs = now
    fromTs = now - (windowMinutes * 60)
  }
  
  // Add Â±5min tolerance to guarantee >=1 candle
  const TOL_SECONDS = 5 * 60
  
  return {
    fromTs: fromTs - TOL_SECONDS,
    toTs: toTs + TOL_SECONDS,
    windowMinutes
  }
}

/**
 * Filter cached data for specific time window and resample to target timeframe
 * Extracts relevant candles and resamples them to the desired granularity
 */
function filterDataForWindow(
  coinCache: CoinCacheData,
  tradeTime: number,
  timeframe: ChartTimeframe
): OHLCPoint[] {
  const { fromTs, toTs } = calculateTradeWindow(tradeTime, timeframe)
  
  console.log(`ðŸ” Filtering for window: ${new Date(fromTs * 1000).toISOString()} â†’ ${new Date(toTs * 1000).toISOString()}`)
  console.log(`ðŸ“Š Target timeframe: ${timeframe}`)
  
  // First resample to target timeframe
  const resampled = resampleToTimeframe(coinCache.rawOHLC, timeframe)
  
  // Then filter for time window
  const filtered = resampled.filter(c => c.timestamp >= fromTs && c.timestamp <= toTs)
  
  console.log(`ðŸŽ¯ Window filter: ${resampled.length} â†’ ${filtered.length} candles`)
  return filtered
}

interface UseCoinGeckoReturn {
  data: MarketChartPoint[] | OHLCPoint[] | null
  loading: boolean
  error: Error | null
  refresh: () => void
}

export function useCoinGecko(
  symbol: string,
  tradeTimestamp: string,
  config: CoinGeckoConfig = { mode: 'ohlc', timeframe: ChartTimeframe.FIVE_MIN, cacheTtl: CacheTTL.LONG }
): UseCoinGeckoReturn {
  const [data, setData] = useState<MarketChartPoint[] | OHLCPoint[] | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  
  // Extract config fields for stable dependencies
  const { mode, timeframe = ChartTimeframe.FIVE_MIN, cacheTtl = CacheTTL.LONG } = config
  
  const fetchData = useCallback(async () => {
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')
    console.log('ðŸ” useCoinGecko: Starting fetch')
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')
    console.log('ðŸ“Š Request:', { symbol, timeframe, mode })
    
    if (!symbol || !tradeTimestamp) {
      setError(new Error('Symbol ve trade timestamp gerekli'))
      setLoading(false)
      return
    }

    setLoading(true)
    setError(null)

    try {
      // 1. Symbol to CoinGecko ID mapping
      const coinId = await symbolToCoinGeckoIdAsync(symbol)
      console.log('ðŸ”„ Mapping:', { symbol, coinId })
      
      if (!coinId) {
        const errorMsg = `Desteklenmeyen sembol: ${symbol}`
        console.error('âŒ', errorMsg)
        setError(new Error(errorMsg))
        setLoading(false)
        return
      }
      
      const tradeTime = Math.floor(new Date(tradeTimestamp).getTime() / 1000)
      
      // 2. Check coin-specific cache (SINGLE SOURCE OF TRUTH)
      let coinCache = CacheManager.getCoinCache(coinId)
      
      if (coinCache) {
        console.log('âœ… Coin cache EXISTS - using cached data')
        console.log('â±ï¸ Applying timeframe filter:', timeframe)
        
        // Extract data for requested timeframe and window
        if (mode === 'ohlc') {
          const filteredData = filterDataForWindow(coinCache, tradeTime, timeframe)
          console.log(`ðŸ“Š Filtered cache: ${filteredData.length} candles for ${timeframe}`)
          setData(filteredData)
          setLoading(false)
          return
        } else {
          // Line chart mode - convert OHLC to price points
          const priceData: MarketChartPoint[] = coinCache.rawOHLC.map(candle => ({
            timestamp: candle.timestamp,
            price: candle.close
          }))
          setData(priceData)
          setLoading(false)
          return
        }
      }
      
      // 3. Cache MISS - fetch from API (ONLY ONCE PER COIN)
      console.log('ï¿½ Coin cache MISS - fetching from API...')
      console.log('âš ï¸ This is the ONLY API call for this coin (rate limit safe)')
      
      const { fromTs, toTs, windowMinutes } = calculateTradeWindow(tradeTime, timeframe)
      
      console.log('ï¿½ Data range:', {
        trade: new Date(tradeTime * 1000).toISOString(),
        from: new Date(fromTs * 1000).toISOString(),
        to: new Date(toTs * 1000).toISOString(),
        windowMinutes
      })
      
      // Fetch OHLC data (1 day = real candlesticks with open/high/low/close)
      const ohlcData = await rateLimiter.add(() =>
        fetchOHLC(coinId, 'usd', 1)
      )
      
      if (!ohlcData || ohlcData.length === 0) {
        throw new Error('No OHLC data received from CoinGecko')
      }
      
      // Convert OHLC array format to OHLCPoint objects
      const allOHLC: OHLCPoint[] = ohlcData.map((point: number[]) => ({
        timestamp: Math.floor(point[0] / 1000),
        open: point[1],
        high: point[2],
        low: point[3],
        close: point[4]
      }))
      
      console.log('Fetched:', allOHLC.length, 'OHLC candles from API')
      
      // Filter to relevant time window
      const rawOHLC = allOHLC.filter(c => c.timestamp >= fromTs && c.timestamp <= toTs)
      console.log('Filtered to:', rawOHLC.length, 'candles for trade window')
      
      // 4. Pre-aggregate data for all timeframes
      const aggregated15m = aggregateTo15Min(rawOHLC)
      
      // 5. Create unified coin cache object
      coinCache = {
        coinId,
        symbol,
        rawOHLC,
        fetchedAt: Date.now(),
        ttl: cacheTtl,
        dataRange: { from: fromTs, to: toTs },
        aggregated: {
          '5m': rawOHLC,           // Native 5m from API
          '15m': aggregated15m,    // Pre-aggregated 15m
          '1m': rawOHLC,           // Fallback to 5m (API limitation)
          '3m': rawOHLC            // Fallback to 5m (API limitation)
        }
      }
      
      // 6. Save to cache (SINGLE WRITE)
      CacheManager.setCoinCache(coinCache)
      
      console.log('âœ… Coin cache SAVED')
      console.log('   â”œâ”€ Total candles:', rawOHLC.length)
      console.log('   â”œâ”€ Aggregated 15m:', aggregated15m.length)
      console.log('   â””â”€ All timeframes ready for instant switching!')
      
      // 7. Return filtered data for current view
      if (mode === 'ohlc') {
        const filteredData = filterDataForWindow(coinCache, tradeTime, timeframe)
        setData(filteredData)
      } else {
        const priceData: MarketChartPoint[] = rawOHLC.map(candle => ({
          timestamp: candle.timestamp,
          price: candle.close
        }))
        setData(priceData)
      }
      
    } catch (err) {
      console.error('âŒ Fetch error:', err)
      setError(err as Error)
    } finally {
      setLoading(false)
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n')
    }
  }, [symbol, tradeTimestamp, mode, timeframe, cacheTtl])
  
  useEffect(() => {
    fetchData()
  }, [fetchData])
  
  return { data, loading, error, refresh: fetchData }
}
