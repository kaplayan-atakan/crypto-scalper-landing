import React, { useEffect, useRef } from 'react'
import type { OHLCPoint } from '../../types/coingecko'

interface BinanceStyleChartProps {
  data: OHLCPoint[]
  volumeData?: Array<{ time: number; value: number; color?: string }>
  height?: number
  showVolume?: boolean
  tradeTimestamp?: string
}

/**
 * Binance-Style Professional Candlestick Chart
 * Uses lightweight-charts with robust API fallbacks
 * 
 * Supports both classic API (addCandlestickSeries) and unified API (addSeries)
 */
export function BinanceStyleChart({
  data,
  volumeData = [],
  height = 400,
  showVolume = true,
  tradeTimestamp,
}: BinanceStyleChartProps) {
  const chartContainerRef = useRef<HTMLDivElement>(null)
  const chartRef = useRef<any>(null)
  const seriesRef = useRef<any>(null)
  const volumeSeriesRef = useRef<any>(null)
  const didInitRef = useRef(false)

  useEffect(() => {
    // Prevent double initialization in React StrictMode
    if (didInitRef.current) {
      console.log('‚è≠Ô∏è BinanceStyleChart: Skipping double init (StrictMode)')
      return
    }

    if (!chartContainerRef.current || data.length === 0) return

    const container = chartContainerRef.current
    let cleanupFn: (() => void) | null = null

    console.log('üìä BinanceStyleChart: Creating chart with', data.length, 'candles')

    // Dynamic import to avoid SSR/HMR issues with lightweight-charts
    ;(async () => {
      try {
        // Import lightweight-charts dynamically (client-only)
        const mod = await import('lightweight-charts')
        const createChartFn = (mod as any).createChart ?? (window as any)?.LightweightCharts?.createChart
        
        // API method names for fallback support
        const addSeriesName = 'addSeries'
        const addCandleName = 'addCandlestickSeries'
        const addHistoName = 'addHistogramSeries'

        // Diagnostics - introspect module and API
        console.log('üì¶ LWC module keys:', Object.keys(mod))
        console.log('üß™ typeof createChart:', typeof createChartFn)

        if (typeof createChartFn !== 'function') {
          console.error('‚ùå BinanceStyleChart: createChart function not found in module or global')
          return
        }

        if (!container || !container.clientWidth) {
          console.error('‚ùå BinanceStyleChart: Container not ready or has zero width')
          return
        }

        // Create chart with Binance styling
        const chart = createChartFn(container, {
          width: container.clientWidth,
          height,

          layout: {
            background: { color: '#1e2329' },
            textColor: '#848e9c',
            fontSize: 11,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "SF Mono", monospace',
          },

          grid: {
            vertLines: {
              color: 'rgba(255, 255, 255, 0.05)',
              style: 0,
              visible: true,
            },
            horzLines: {
              color: 'rgba(255, 255, 255, 0.08)',
              style: 0,
              visible: true,
            },
          },

          crosshair: {
            mode: 1, // Normal crosshair
            vertLine: {
              color: 'rgba(255, 255, 255, 0.3)',
              width: 1,
              style: 0,
              labelVisible: false,
            },
            horzLine: {
              color: 'rgba(255, 255, 255, 0.3)',
              width: 1,
              style: 0,
              labelVisible: true,
              labelBackgroundColor: '#2b3139',
            },
          },

          rightPriceScale: {
            borderColor: 'rgba(255, 255, 255, 0.1)',
            borderVisible: true,
            scaleMargins: {
              top: 0.1,
              bottom: showVolume ? 0.3 : 0.1,
            },
            entireTextOnly: false,
          },

          timeScale: {
            borderColor: 'rgba(255, 255, 255, 0.1)',
            borderVisible: true,
            timeVisible: true,
            secondsVisible: false,
            rightOffset: 5,
            barSpacing: 8,
            minBarSpacing: 3,
            fixLeftEdge: false,
            fixRightEdge: false,
            lockVisibleTimeRangeOnResize: true,
          },

          handleScroll: {
            mouseWheel: true,
            pressedMouseMove: true,
            horzTouchDrag: true,
            vertTouchDrag: true,
          },

          handleScale: {
            axisPressedMouseMove: true,
            mouseWheel: true,
            pinch: true,
          },
        })

        // Introspect chart API for debugging
        const hasAddCandles = typeof (chart as any)?.[addCandleName] === 'function'
        const hasAddSeries = typeof (chart as any)?.[addSeriesName] === 'function'
        const hasAddHistogram = typeof (chart as any)?.[addHistoName] === 'function'

        console.log('üîé Chart API introspection:', {
          hasAddCandlestickSeries: hasAddCandles,
          hasAddSeries: hasAddSeries,
          hasAddHistogramSeries: hasAddHistogram,
          prototypeKeys: Object.getOwnPropertyNames(Object.getPrototypeOf(chart) || {}),
        })

        if (!hasAddCandles && !hasAddSeries) {
          console.error('‚ùå BinanceStyleChart: No series factory available on chart instance')
          console.error('Available methods:', Object.keys(chart))
          return
        }

        chartRef.current = chart
        didInitRef.current = true

        console.log('‚úÖ BinanceStyleChart: Chart instance created successfully')

        // Add candlestick series with Binance colors
        // Try classic API first, fallback to unified API
        const candleOptions = {
          upColor: '#0ecb81', // Binance green
          downColor: '#f6465d', // Binance red
          borderUpColor: '#0ecb81',
          borderDownColor: '#f6465d',
          wickUpColor: '#0ecb81',
          wickDownColor: '#f6465d',
          borderVisible: true,
          wickVisible: true,
          priceLineVisible: true,
          lastValueVisible: true,
          priceFormat: {
            type: 'price',
            precision: 2,
            minMove: 0.01,
          },
        }

        const candleSeries = hasAddCandles
          ? (chart as any)[addCandleName](candleOptions)
          : (chart as any)[addSeriesName]({ type: 'Candlestick', ...candleOptions })

        seriesRef.current = candleSeries

        // Convert OHLCPoint[] to candlestick data
        const candlestickData = data.map((candle) => ({
          time: candle.timestamp,
          open: candle.open,
          high: candle.high,
          low: candle.low,
          close: candle.close,
        }))

        candleSeries.setData(candlestickData)

        console.log('‚úÖ Candlestick data loaded:', candlestickData.length, 'candles')

        // Add volume histogram if data available
        // Try classic API first, fallback to unified API
        if (showVolume && volumeData.length > 0) {
          const volumeOptions = {
            color: '#26a69a',
            priceFormat: {
              type: 'volume',
            },
            priceScaleId: '', // Separate scale for volume
            scaleMargins: {
              top: 0.7, // Volume takes bottom 30%
              bottom: 0,
            },
          }

          const volSeries = hasAddHistogram
            ? (chart as any)[addHistoName](volumeOptions)
            : (chart as any)[addSeriesName]({ type: 'Histogram', ...volumeOptions })

          volumeSeriesRef.current = volSeries

          // Color volume bars based on price direction
          const coloredVolumeData = volumeData.map((vol, idx) => {
            const isUp = idx === 0 || data[idx].close >= data[idx].open
            return {
              time: vol.time,
              value: vol.value,
              color: isUp ? 'rgba(14, 203, 129, 0.5)' : 'rgba(246, 70, 93, 0.5)',
            }
          })

          volSeries.setData(coloredVolumeData)
          console.log('‚úÖ Volume data loaded:', coloredVolumeData.length, 'bars')
        }

        // Current price line (last close price)
        if (data.length > 0 && typeof candleSeries.createPriceLine === 'function') {
          const lastCandle = data[data.length - 1]
          candleSeries.createPriceLine({
            price: lastCandle.close,
            color: '#2962ff',
            lineWidth: 1,
            lineStyle: 2, // Dashed
            axisLabelVisible: true,
            title: '',
          })
          console.log('‚úÖ Current price line:', lastCandle.close)
        }

        // Trade execution marker (optional)
        if (tradeTimestamp && typeof candleSeries.setMarkers === 'function') {
          const tradeTime = Math.floor(new Date(tradeTimestamp).getTime() / 1000)
          console.log('üéØ Trade marker at:', new Date(tradeTime * 1000).toISOString())

          const markers = [
            {
              time: tradeTime,
              position: 'inBar' as const,
              color: '#ff0066',
              shape: 'arrowUp' as const,
              text: 'Trade',
            },
          ]
          candleSeries.setMarkers(markers)
        }

        // Fit content
        chart.timeScale().fitContent()

        // Responsive resize
        const handleResize = () => {
          if (container && chart) {
            chart.applyOptions({
              width: container.clientWidth,
            })
          }
        }

        window.addEventListener('resize', handleResize)

        // Setup cleanup function
        cleanupFn = () => {
          console.log('üßπ BinanceStyleChart: Cleaning up chart')
          window.removeEventListener('resize', handleResize)
          if (chart && typeof chart.remove === 'function') {
            chart.remove()
          }
          chartRef.current = null
          seriesRef.current = null
          volumeSeriesRef.current = null
          didInitRef.current = false
        }
      } catch (err) {
        console.error('‚ùå BinanceStyleChart: Failed to create chart:', err)
      }
    })()

    // Cleanup
    return () => {
      if (cleanupFn) {
        cleanupFn()
      }
    }
  }, [data, volumeData, height, showVolume, tradeTimestamp])

  if (!data || data.length === 0) {
    return (
      <div
        style={{
          width: '100%',
          height,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          background: '#1e2329',
          borderRadius: '8px',
          color: '#848e9c',
        }}
      >
        <div style={{ textAlign: 'center' }}>
          <div style={{ fontSize: '24px', marginBottom: '8px' }}>üìä</div>
          <div style={{ fontSize: '14px' }}>No chart data available</div>
        </div>
      </div>
    )
  }

  return (
    <div
      ref={chartContainerRef}
      style={{
        position: 'relative',
        width: '100%',
        height,
        borderRadius: '8px',
        overflow: 'hidden',
      }}
    />
  )
}
